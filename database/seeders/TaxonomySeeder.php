<?php

namespace Database\Seeders;

use App\Models\TaxonomyRule;
use App\Models\TaxonomyTerm;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

/**
 * TaxonomySeeder â€” loads the GAM controlled vocabulary from JSON seed files.
 *
 * Source: database/data/taxonomy_terms.json (805 terms)
 *         database/data/taxonomy_synonyms.json (945 synonym mappings)
 *
 * Generated by: scripts/export_taxonomy.py from the master XLSX workbook.
 *
 * Usage:
 *   php artisan db:seed --class=TaxonomySeeder
 *   php artisan db:seed  (also runs via DatabaseSeeder)
 */
class TaxonomySeeder extends Seeder
{
    public function run(): void
    {
        $this->seedTerms();
        $this->seedSynonyms();

        TaxonomyTerm::clearTaxonomyCache();
        TaxonomyRule::clearCache();

        $this->command->info('Taxonomy seeding complete.');
    }

    private function seedTerms(): void
    {
        $file = database_path('data/taxonomy_terms.json');

        if (! file_exists($file)) {
            $this->command->error("Missing: {$file}. Run: python scripts/export_taxonomy.py");
            return;
        }

        $terms = json_decode(file_get_contents($file), true);

        if (empty($terms)) {
            $this->command->warn('taxonomy_terms.json is empty.');
            return;
        }

        // Truncate and re-seed for idempotency
        DB::table('taxonomy_terms')->truncate();

        $chunks = array_chunk($terms, 100);
        $total = 0;

        foreach ($chunks as $chunk) {
            $rows = [];
            foreach ($chunk as $i => $term) {
                $rows[] = [
                    'term_type'   => $term['term_type'],
                    'group_code'  => $term['group_code'] ?? '',
                    'facet'       => $term['facet'] ?? null,
                    'term_code'   => $term['term_code'] ?? null,
                    'term_label'  => $term['term_label'],
                    'parent_code' => $term['parent_code'] ?? null,
                    'description' => $term['description'] ?? null,
                    'extra'       => isset($term['extra']) ? json_encode($term['extra']) : null,
                    'sort_order'  => $total + $i,
                    'is_active'   => true,
                    'created_at'  => now(),
                    'updated_at'  => now(),
                ];
            }

            DB::table('taxonomy_terms')->insert($rows);
            $total += count($rows);
        }

        $this->command->info("  Loaded {$total} taxonomy terms.");
    }

    private function seedSynonyms(): void
    {
        $file = database_path('data/taxonomy_synonyms.json');

        if (! file_exists($file)) {
            $this->command->error("Missing: {$file}. Run: python scripts/export_taxonomy.py");
            return;
        }

        $synonyms = json_decode(file_get_contents($file), true);

        if (empty($synonyms)) {
            $this->command->warn('taxonomy_synonyms.json is empty.');
            return;
        }

        // Truncate and re-seed for idempotency
        DB::table('taxonomy_rules')->truncate();

        $chunks = array_chunk($synonyms, 100);
        $total = 0;
        $skipped = 0;

        foreach ($chunks as $chunk) {
            $rows = [];
            $seen = [];

            foreach ($chunk as $syn) {
                $raw = strtolower(trim($syn['raw_term'] ?? ''));
                $canonical = trim($syn['canonical_term'] ?? '');

                if (! $raw || ! $canonical) {
                    $skipped++;
                    continue;
                }

                // Avoid duplicate raw_term + canonical_term combos
                $key = "{$raw}|{$canonical}";
                if (isset($seen[$key])) {
                    $skipped++;
                    continue;
                }
                $seen[$key] = true;

                $rows[] = [
                    'raw_term'       => $raw,
                    'canonical_term' => $canonical,
                    'group_hint'     => $syn['group_hint'] ?? null,
                    'is_active'      => true,
                    'created_at'     => now(),
                    'updated_at'     => now(),
                ];
            }

            if (! empty($rows)) {
                // Use upsert to handle cross-chunk duplicates
                foreach ($rows as $row) {
                    try {
                        DB::table('taxonomy_rules')->insert($row);
                        $total++;
                    } catch (\Illuminate\Database\QueryException $e) {
                        if (str_contains($e->getMessage(), 'Duplicate entry')) {
                            $skipped++;
                        } else {
                            throw $e;
                        }
                    }
                }
            }
        }

        $this->command->info("  Loaded {$total} synonym rules (skipped {$skipped} duplicates).");
    }
}
